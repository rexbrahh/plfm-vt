// This file is @generated by prost-build.
/// Actor types for audit attribution.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ActorType {
    /// Actor type is unspecified.
    Unspecified = 0,
    /// End-user actor.
    User = 1,
    /// Service principal actor.
    ServicePrincipal = 2,
    /// Internal system actor.
    System = 3,
}
impl ActorType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ACTOR_TYPE_UNSPECIFIED",
            Self::User => "ACTOR_TYPE_USER",
            Self::ServicePrincipal => "ACTOR_TYPE_SERVICE_PRINCIPAL",
            Self::System => "ACTOR_TYPE_SYSTEM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ACTOR_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "ACTOR_TYPE_USER" => Some(Self::User),
            "ACTOR_TYPE_SERVICE_PRINCIPAL" => Some(Self::ServicePrincipal),
            "ACTOR_TYPE_SYSTEM" => Some(Self::System),
            _ => None,
        }
    }
}
/// Aggregate types for event log scoping.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AggregateType {
    /// Aggregate type is unspecified.
    Unspecified = 0,
    /// Organization aggregate.
    Org = 1,
    /// Project aggregate.
    Project = 2,
    /// Organization member aggregate.
    OrgMember = 3,
    /// Service principal aggregate.
    ServicePrincipal = 4,
    /// Application aggregate.
    App = 5,
    /// Environment aggregate.
    Env = 6,
    /// Release aggregate.
    Release = 7,
    /// Deploy aggregate.
    Deploy = 8,
    /// Route aggregate.
    Route = 9,
    /// Secret bundle aggregate.
    SecretBundle = 10,
    /// Volume aggregate.
    Volume = 11,
    /// Volume attachment aggregate.
    VolumeAttachment = 12,
    /// Snapshot aggregate.
    Snapshot = 13,
    /// Restore job aggregate.
    RestoreJob = 14,
    /// Instance aggregate.
    Instance = 15,
    /// Node aggregate.
    Node = 16,
    /// Exec session aggregate.
    ExecSession = 17,
}
impl AggregateType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "AGGREGATE_TYPE_UNSPECIFIED",
            Self::Org => "AGGREGATE_TYPE_ORG",
            Self::Project => "AGGREGATE_TYPE_PROJECT",
            Self::OrgMember => "AGGREGATE_TYPE_ORG_MEMBER",
            Self::ServicePrincipal => "AGGREGATE_TYPE_SERVICE_PRINCIPAL",
            Self::App => "AGGREGATE_TYPE_APP",
            Self::Env => "AGGREGATE_TYPE_ENV",
            Self::Release => "AGGREGATE_TYPE_RELEASE",
            Self::Deploy => "AGGREGATE_TYPE_DEPLOY",
            Self::Route => "AGGREGATE_TYPE_ROUTE",
            Self::SecretBundle => "AGGREGATE_TYPE_SECRET_BUNDLE",
            Self::Volume => "AGGREGATE_TYPE_VOLUME",
            Self::VolumeAttachment => "AGGREGATE_TYPE_VOLUME_ATTACHMENT",
            Self::Snapshot => "AGGREGATE_TYPE_SNAPSHOT",
            Self::RestoreJob => "AGGREGATE_TYPE_RESTORE_JOB",
            Self::Instance => "AGGREGATE_TYPE_INSTANCE",
            Self::Node => "AGGREGATE_TYPE_NODE",
            Self::ExecSession => "AGGREGATE_TYPE_EXEC_SESSION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AGGREGATE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "AGGREGATE_TYPE_ORG" => Some(Self::Org),
            "AGGREGATE_TYPE_PROJECT" => Some(Self::Project),
            "AGGREGATE_TYPE_ORG_MEMBER" => Some(Self::OrgMember),
            "AGGREGATE_TYPE_SERVICE_PRINCIPAL" => Some(Self::ServicePrincipal),
            "AGGREGATE_TYPE_APP" => Some(Self::App),
            "AGGREGATE_TYPE_ENV" => Some(Self::Env),
            "AGGREGATE_TYPE_RELEASE" => Some(Self::Release),
            "AGGREGATE_TYPE_DEPLOY" => Some(Self::Deploy),
            "AGGREGATE_TYPE_ROUTE" => Some(Self::Route),
            "AGGREGATE_TYPE_SECRET_BUNDLE" => Some(Self::SecretBundle),
            "AGGREGATE_TYPE_VOLUME" => Some(Self::Volume),
            "AGGREGATE_TYPE_VOLUME_ATTACHMENT" => Some(Self::VolumeAttachment),
            "AGGREGATE_TYPE_SNAPSHOT" => Some(Self::Snapshot),
            "AGGREGATE_TYPE_RESTORE_JOB" => Some(Self::RestoreJob),
            "AGGREGATE_TYPE_INSTANCE" => Some(Self::Instance),
            "AGGREGATE_TYPE_NODE" => Some(Self::Node),
            "AGGREGATE_TYPE_EXEC_SESSION" => Some(Self::ExecSession),
            _ => None,
        }
    }
}
/// Error metadata included in API responses.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorDetail {
    /// Request correlation id.
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    /// Resource type for the failing request.
    #[prost(string, tag = "2")]
    pub resource_type: ::prost::alloc::string::String,
    /// Resource id for the failing request.
    #[prost(string, tag = "3")]
    pub resource_id: ::prost::alloc::string::String,
    /// Whether the error is retryable.
    #[prost(bool, tag = "4")]
    pub retryable: bool,
    /// Suggested retry delay in seconds.
    #[prost(uint32, tag = "5")]
    pub retry_after_seconds: u32,
    /// Human-friendly hint for operators.
    #[prost(string, tag = "6")]
    pub human_hint: ::prost::alloc::string::String,
    /// Structured error tags for diagnostics.
    #[prost(map = "string, string", tag = "7")]
    pub tags: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Time range for filtering queries.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TimeRange {
    /// Start of the time range (inclusive).
    #[prost(message, optional, tag = "1")]
    pub start: ::core::option::Option<::prost_types::Timestamp>,
    /// End of the time range (exclusive).
    #[prost(message, optional, tag = "2")]
    pub end: ::core::option::Option<::prost_types::Timestamp>,
}
/// Deadline configuration for operations.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Deadline {
    /// Absolute deadline timestamp.
    #[prost(message, optional, tag = "1")]
    pub deadline_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Relative timeout duration from request time.
    #[prost(message, optional, tag = "2")]
    pub timeout: ::core::option::Option<::prost_types::Duration>,
}
/// Retry configuration for operations.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RetryPolicy {
    /// Maximum number of retry attempts.
    #[prost(int32, tag = "1")]
    pub max_attempts: i32,
    /// Initial backoff duration.
    #[prost(message, optional, tag = "2")]
    pub initial_backoff: ::core::option::Option<::prost_types::Duration>,
    /// Maximum backoff duration.
    #[prost(message, optional, tag = "3")]
    pub max_backoff: ::core::option::Option<::prost_types::Duration>,
    /// Backoff multiplier.
    #[prost(double, tag = "4")]
    pub backoff_multiplier: f64,
}
/// TTL configuration for resources.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TimeToLive {
    /// Duration until expiration.
    #[prost(message, optional, tag = "1")]
    pub ttl: ::core::option::Option<::prost_types::Duration>,
    /// Absolute expiration timestamp.
    #[prost(message, optional, tag = "2")]
    pub expires_at: ::core::option::Option<::prost_types::Timestamp>,
}
